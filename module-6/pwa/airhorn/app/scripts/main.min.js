/*
 *
 *  Air Horner
 *  Copyright 2015 Google Inc. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the 'License');
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an 'AS IS' BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 *
 */
(function() {
'use strict';

const Horn = function() {
  // The Horn Player.

  const audioSrc = '/sounds/airhorn.mp3';
  let noAudioContext = false;
  let fallbackAudio;
  let audioCtx = (window.AudioContext || window.webkitAudioContext);
  const self = this;
  let source;
  let buffer;

  if (audioCtx !== undefined) {
    audioCtx = new audioCtx();
  } else {
    noAudioContext = true;
    fallbackAudio = document.createElement('audio');
  }

  const loadSound = function(callback) {
    callback = callback || function() {};

    if (noAudioContext) {
      fallbackAudio.src = audioSrc;
      return;
    }

    // AudioContext must be resumed after the document received a user gesture to enable audio playback.
    audioCtx.resume();

    if (!!buffer == true) {
      // If the buffer is already loaded, use that.
      callback(buffer);
      return;
    }

    const xhr = new XMLHttpRequest();

    xhr.onload = function() {
      audioCtx.decodeAudioData(xhr.response, function(decodedBuffer) {
        callback(decodedBuffer);
      });
    };

    xhr.open('GET', audioSrc);
    xhr.responseType = 'arraybuffer';
    xhr.send();
  };


  this.start = function(opts) {
    const shouldLoop = opts.loop; // always loop if from an event.

    if (noAudioContext) {
      fallbackAudio.loop = shouldLoop;
      fallbackAudio.currentTime = 0;
      fallbackAudio.play();
      return;
    }

    loadSound(function(tmpBuffer) {
      source = audioCtx.createBufferSource();

      source.connect(audioCtx.destination);

      source.buffer = tmpBuffer;

      source.onended = function() {
        self.stop();
      };

      source.start(0);
      source.loop = shouldLoop;
      source.loopStart = 0.24;
      source.loopEnd = 0.34;
    });
  };

  this.stop = function() {
    if (!!source === true) {
      source.loop = false;
    }

    if (noAudioContext) {
      fallbackAudio.loop = false;
      fallbackAudio.pause();
    }

    this.onstopped();
  };

  this.onstopped = function() {};

  const init = function() {
    loadSound(function(decodedBuffer) {
      buffer = decodedBuffer;
    });
  };

  init();
};

const Installer = function(root) {
  let promptEvent;

  const install = function(e) {
    if(promptEvent) {
      promptEvent.prompt();
      promptEvent.userChoice
        .then(function(choiceResult) {
          // The user actioned the prompt (good or bad).
          // good is handled in
          promptEvent = null;
          ga('send', 'event', 'install', choiceResult);
          root.classList.remove('available');
        })
        .catch(function(installError) {
          // Boo. update the UI.
          promptEvent = null;
          ga('send', 'event', 'install', 'errored');
          root.classList.remove('available');
        });
    }
  };

  const installed = function(e) {
    promptEvent = null;
    // This fires after onbeforinstallprompt OR after manual add to homescreen.
    ga('send', 'event', 'install', 'installed');
    root.classList.remove('available');
  };

  const beforeinstallprompt = function(e) {
    promptEvent = e;
    promptEvent.preventDefault();
    ga('send', 'event', 'install', 'available');
    root.classList.add('available');
    return false;
  };

  window.addEventListener('beforeinstallprompt', beforeinstallprompt);
  window.addEventListener('appinstalled', installed);

  root.addEventListener('click', install.bind(this));
  root.addEventListener('touchend', install.bind(this));
};

const AirHorn = function(root) {
  // Controls the AirHorn.

  const airhornImage = root.querySelector('.horn');
  const horn = new Horn();

  // Reset badge upon each relaunch
  if ('clearAppBadge' in navigator) {
    navigator.clearAppBadge();
  }
  let counter = 0;

  const start = function(e) {
    if (!!e == true) {
      if(supportsPassive == false) e.preventDefault();

      if (e.touches && e.touches.length > 1) {
        // Multi touch. OFF.
        return false;
      }
    }

    this.start({loop: true});
  };

  const stop = function(e) {
    if (!!e == true) e.preventDefault();
    this.stop();
  };

  this.start = function(opts) {
    // Play the sound
    airhornImage.classList.add('horning');
    airhornImage.setAttribute('aria-pressed', 'true');
    horn.start(opts);

    // Counter counts honks up until 99, then resets to 0
    if ('setAppBadge' in navigator) {
      if (counter === 99) {
        counter = 0;
      }
      navigator.setAppBadge(++counter);
    }

    horn.onstopped = function() {
      airhornImage.classList.remove('horning');
      airhornImage.setAttribute('aria-pressed', 'false');
    };
    
    ga('send', 'event', 'horn', 'play');
  };

  this.stop = function() {
    // Stop the sound
    airhornImage.classList.remove('horning');
    horn.stop();
  };

  // Test to see if passive events listener are supported.
  let supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, 'passive', {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {}

  airhornImage.addEventListener('mousedown', start.bind(this),
      supportsPassive ? {passive: true} : false);
  airhornImage.addEventListener('touchstart', start.bind(this),
      supportsPassive ? {passive: true} : false);

  let pressing = false;

  airhornImage.addEventListener('keydown', function(event) {
    const validKeys = ['Space', 'Enter', 'SoftCenter', 'Digit5']
    if (pressing == false && validKeys.includes(event.code)) {
      event.preventDefault();
      start.call(this);
      pressing = true;
    }
  }.bind(this), false);

  document.documentElement.addEventListener('mouseup', stop.bind(this));
  document.documentElement.addEventListener('touchend', stop.bind(this));
  document.documentElement.addEventListener('keyup', function() {
    if (pressing == true) {
      stop.call(this);
      pressing = false;
    }
  }.bind(this));
};

window.addEventListener('load', function() {
  const airhornEl = document.getElementById('airhorn');
  const installEl = document.getElementById('installer');
  const airhorn = new AirHorn(airhornEl);
  const installer = new Installer(installEl);
  let isLooping = false;

  if (Comlink && window.opener) {
    // We are ready. Tell the opener.
    const channel = new MessageChannel();
    const port1 = channel.port1;
    Comlink.expose(airhorn, port1);
    opener.postMessage({'cmd': 'READY'}, '*', [channel.port2]);
  }

  if (navigator.presentation && navigator.presentation.receiver) {
    navigator.presentation.receiver.connectionList.then(list => {
      list.connections.forEach(connection => {
        Comlink.expose(airhorn, MessageChannelAdapter.wrap(connection));
      });
      list.onconnectionavailable = event => {
        Comlink.expose(airhorn, MessageChannelAdapter.wrap(event.connection));
      };
    });
  }

  if (location.hash == '#instant') {
    airhorn.start({loop: false});
  }

  window.addEventListener('hashchange', function() {
    if (location.hash == '#instant') {
      airhorn.start({loop: false});
    }
  });

  document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
      airhorn.stop();
    }
  });
});
})();
